import type { ThinEngine } from "@babylonjs/core/Engines/thinEngine.js";
import {
    CustomShaderBlock,
    type BaseBlock,
    type ISerializedBlockV1,
    type SmartFilter,
    type SmartFilterDeserializer,
    type SerializedShaderBlockDefinition,
} from "../../../../index.js";

// ************************************************************
// Note: this file is auto-generated, do not modify it directly
// ************************************************************

// It was generated by convertShaderIntoCustomBlockFile() from
// an annotated .glsl file. Modify the .glsl file to make changes
// to the shader. This file will get overwritten when the build
// is run or during a watch when the .glsl file is updated.

/**
 * Generates a block from an annotated GLSL file.
 * @param smartFilter - The smart filter to create the block for
 * @param _engine - The engine to use for creating blocks
 * @param _smartFilterDeserializer - The deserializer to use for deserializing blocks
 * @param serializedBlock - The serialized block to deserialize, if any
 * @returns - A CustomShaderBlock that implements the block described in the annotated GLSL file
 */
export function factory(
    smartFilter: SmartFilter,
    _engine: ThinEngine,
    _smartFilterDeserializer: SmartFilterDeserializer,
    serializedBlock?: ISerializedBlockV1
): BaseBlock {
    return CustomShaderBlock.Create(
        smartFilter,
        serializedBlock?.name || blockDefinition.blockType.replace("Block", ""),
        blockDefinition as SerializedShaderBlockDefinition
    );
}

const blockDefinition = {
    format: "shaderBlockDefinition",
    formatVersion: 1,
    blockType: "WipeBlock",
    namespace: "Babylon.Demo.Transitions",
    shaderProgram: {
        fragment: {
            uniform: "uniform sampler2D _textureA_;\nuniform sampler2D _textureB_; // main\nuniform float _progress_;",
            mainFunctionName: "_wipe_",
            mainInputTexture: "_textureB_",
            functions: [
                {
                    name: "_wipe_",
                    code: "vec4 _wipe_(vec2 vUV) { \n    vec4 colorA = texture2D(_textureA_, vUV);\n    vec4 colorB = texture2D(_textureB_, vUV);\n    return mix(colorB, colorA, step(_progress_, vUV.y));\n}\n",
                },
            ],
        },
    },
    inputConnectionPoints: [
        {
            name: "textureA",
            type: 2,
            autoBind: undefined,
        },
        {
            name: "textureB",
            type: 2,
            autoBind: undefined,
        },
        {
            name: "progress",
            type: 1,
            autoBind: undefined,
        },
    ],
    disableOptimization: false,
};
