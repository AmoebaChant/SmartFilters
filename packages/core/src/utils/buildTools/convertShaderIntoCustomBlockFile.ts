import { importCustomBlockDefinition } from "../../serialization/importCustomBlockDefinition.js";
import * as fs from "fs";

const BLOCK_DEFINITION = "@BLOCK_DEFINITION@";

const FileTemplate = `import type { ThinEngine } from "@babylonjs/core/Engines/thinEngine.js";
import {
    CustomShaderBlock,
    type BaseBlock,
    type ISerializedBlockV1,
    type SmartFilter,
    type SmartFilterDeserializer,
} from "../../../../index.js";

// ************************************************************
// Note: this file is auto-generated, do not modify it directly
// ************************************************************

// It was generated by convertShaderIntoCustomBlockFile() from
// an annotated .glsl file. Modify the .glsl file to make changes
// to the shader. This file will get overwritten when the build
// is run or during a watch when the .glsl file is updated.

/**
 * Generates a block from an annotated GLSL file.
 * @param smartFilter - The smart filter to create the block for
 * @param _engine - The engine to use for creating blocks
 * @param _smartFilterDeserializer - The deserializer to use for deserializing blocks
 * @param serializedBlock - The serialized block to deserialize, if any
 * @returns - A CustomShaderBlock that implements the block described in the annotated GLSL file
 */
export function factory(
    smartFilter: SmartFilter,
    _engine: ThinEngine,
    _smartFilterDeserializer: SmartFilterDeserializer,
    serializedBlock?: ISerializedBlockV1
): BaseBlock {
    const blockDefinition = JSON.parse(blockDefinitionJSON);
    if (blockDefinition.format !== "shaderBlockDefinition") {
        throw new Error("Expected a serialized ShaderBlockDefinition");
    }
    return CustomShaderBlock.Create(
        smartFilter,
        serializedBlock?.name || blockDefinition.blockType.replace("Block", ""),
        blockDefinition
    );
}

const blockDefinitionJSON = \`${BLOCK_DEFINITION}\`;
`;

/**
 * Converts a single shader to a .ts file which creates the shader as a custom block
 * @param fragmentFullPathAndFileName - The path to the fragment file for the shader
 */
export function convertShaderIntoCustomBlockFile(fragmentFullPathAndFileName: string): void {
    // See if there is a corresponding vertex shader
    const vertexShaderPath = fragmentFullPathAndFileName.replace(".fragment.glsl", ".vertex.glsl");
    if (fs.existsSync(vertexShaderPath)) {
        console.error(
            "Found vertex shader - this is not supported yet for custom blocks - consider creating a .ts block definition that imports this shader instead."
        );
        return;
    }

    // Read the annotated fragment shader glsl
    const annotatedFragmentGlsl = fs.readFileSync(fragmentFullPathAndFileName, "utf8");

    // Parse
    const blockDefinition = importCustomBlockDefinition(annotatedFragmentGlsl);

    // Write the shader TS file
    const outputFullPathAndFileName = fragmentFullPathAndFileName.replace(".fragment.glsl", ".autogen.customBlock.ts");
    console.log(`Writing custom block file: ${outputFullPathAndFileName}`);
    const finalContents = FileTemplate.replace(
        BLOCK_DEFINITION,
        JSON.stringify(blockDefinition).replace(/\\n/g, "\\\\n")
    );

    fs.writeFileSync(outputFullPathAndFileName, finalContents);
}
