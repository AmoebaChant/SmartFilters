import * as fs from "fs";
import { importCustomBlockDefinition } from "../../serialization/importCustomBlockDefinition.js";

const BLOCK_DEFINITION = "@BLOCK_DEFINITION@";

const FileTemplate = `import type { ThinEngine } from "@babylonjs/core/Engines/thinEngine.js";
import {
    CustomShaderBlock,
    type BaseBlock,
    type ISerializedBlockV1,
    type SmartFilter,
    type SmartFilterDeserializer,
} from "@babylonjs/smart-filters";

// ************************************************************
// Note: this file is auto-generated, do not modify it directly
// ************************************************************

// It was generated by convertShaderIntoCustomBlockFile() from
// an annotated .glsl file. Modify the .glsl file to make changes
// to the shader. This file will get overwritten when the build
// is run or during a watch when the .glsl file is updated.

/**
 * Generates a block from an annotated GLSL file.
 * @param smartFilter - The smart filter to create the block for
 * @param _engine - The engine to use for creating blocks
 * @param _smartFilterDeserializer - The deserializer to use for deserializing blocks
 * @param serializedBlock - The serialized block to deserialize, if any
 * @returns - A CustomShaderBlock that implements the block described in the annotated GLSL file
 */
export function wipeBlockFactory(
    smartFilter: SmartFilter,
    _engine: ThinEngine,
    _smartFilterDeserializer: SmartFilterDeserializer,
    serializedBlock?: ISerializedBlockV1
): BaseBlock {
    if (blockDefinition.format !== "shaderBlockDefinition") {
        throw new Error("Expected a serialized ShaderBlockDefinition");
    }
    return CustomShaderBlock.Create(smartFilter, serializedBlock?.name || "Wipe", blockDefinition);
}

const blockDefinition = JSON.parse('${BLOCK_DEFINITION}');
`;

/**
 * Converts a single shader to a .ts file which creates the shader as a custom block
 * @param fragmentFullPathAndFileName - The path to the fragment file for the shader
 */
export function convertShaderIntoCustomBlockFile(fragmentFullPathAndFileName: string): void {
    // See if there is a corresponding vertex shader
    const vertexShaderPath = fragmentFullPathAndFileName.replace(".fragment.glsl", ".vertex.glsl");
    if (fs.existsSync(vertexShaderPath)) {
        console.error(
            "Found vertex shader - this is not supported yet for custom blocks - consider creating a .ts block definition that imports this shader instead."
        );
        return;
    }

    // Read the fragment shader
    const annotatedGlsl = fs.readFileSync(fragmentFullPathAndFileName, "utf8");

    // TODO: solve: can't import this - it's not in the build tools folder which can't take a dependency on the core files since they aren't built yet...

    const blockDefinition = importCustomBlockDefinition(annotatedGlsl);

    // Write the shader TS file
    const outputFullPathAndFileName = fragmentFullPathAndFileName.replace(".fragment.glsl", ".autogen.customBlock.ts");
    const finalContents = FileTemplate.replace(BLOCK_DEFINITION, JSON.stringify(blockDefinition));

    fs.writeFileSync(outputFullPathAndFileName, finalContents);
}
