import { importCustomBlockDefinition } from "../../serialization/importCustomBlockDefinition.js";
import * as fs from "fs";

const BLOCK_DEFINITION = "@BLOCK_DEFINITION@";

const FileTemplate = `import type { ThinEngine } from "@babylonjs/core/Engines/thinEngine.js";
import {
    CustomShaderBlock,
    type BaseBlock,
    type ISerializedBlockV1,
    type SmartFilter,
    type SmartFilterDeserializer,
    type SerializedShaderBlockDefinition,
} from "../../../../index.js";

// ************************************************************
// Note: this file is auto-generated, do not modify it directly
// ************************************************************

// It was generated by convertShaderIntoCustomBlockFile() from
// an annotated .glsl file. Modify the .glsl file to make changes
// to the shader. This file will get overwritten when the build
// is run or during a watch when the .glsl file is updated.

/**
 * Generates a block from an annotated GLSL file.
 * @param smartFilter - The smart filter to create the block for
 * @param _engine - The engine to use for creating blocks
 * @param _smartFilterDeserializer - The deserializer to use for deserializing blocks
 * @param serializedBlock - The serialized block to deserialize, if any
 * @returns - A CustomShaderBlock that implements the block described in the annotated GLSL file
 */
export function factory(
    smartFilter: SmartFilter,
    _engine: ThinEngine,
    _smartFilterDeserializer: SmartFilterDeserializer,
    serializedBlock?: ISerializedBlockV1
): BaseBlock {
    return CustomShaderBlock.Create(
        smartFilter,
        serializedBlock?.name || blockDefinition.blockType.replace("Block", ""),
        blockDefinition as SerializedShaderBlockDefinition
    );
}

const blockDefinition = ${BLOCK_DEFINITION};
`;

/**
 * Converts a single shader to a .ts file which creates the shader as a custom block
 * @param fragmentFullPathAndFileName - The path to the fragment file for the shader
 */
export function convertShaderIntoCustomBlockFile(fragmentFullPathAndFileName: string): void {
    // See if there is a corresponding vertex shader
    const vertexShaderPath = fragmentFullPathAndFileName.replace(".fragment.glsl", ".vertex.glsl");
    if (fs.existsSync(vertexShaderPath)) {
        console.error(
            "Found vertex shader - this is not supported yet for custom blocks - consider creating a .ts block definition that imports this shader instead."
        );
        return;
    }

    // Read the annotated fragment shader glsl
    const annotatedFragmentGlsl = fs.readFileSync(fragmentFullPathAndFileName, "utf8");

    // Parse
    const blockDefinition = importCustomBlockDefinition(annotatedFragmentGlsl);

    // Write the shader TS file
    const outputFullPathAndFileName = fragmentFullPathAndFileName.replace(".fragment.glsl", ".autogen.customBlock.ts");
    const finalContents = FileTemplate.replace(BLOCK_DEFINITION, objectToJsString(blockDefinition));

    fs.writeFileSync(outputFullPathAndFileName, finalContents);
}

/**
 * Converts an object into valid JS that creates that object
 * @param obj - The object to convert
 * @param indent - The indent to use for the object
 * @returns - A string that contains JS that creates the object
 */
function objectToJsString(obj: any, indent: string = indentation): string {
    if (typeof obj !== "object" || obj === null) {
        return JSON.stringify(obj);
    }

    if (Array.isArray(obj)) {
        const arrayItems = obj.map((item) => objectToJsString(item, indent + indentation));
        return `[\n${indent}${arrayItems.join(`,\n${indent}`)},\n${indent.slice(indentationSize)}]`;
    }

    const entries = Object.entries(obj).map(([key, value]) => {
        const formattedValue = objectToJsString(value, indent + indentation);
        return `${indent}${key}: ${formattedValue}`;
    });
    return `{\n${entries.join(",\n")},\n${indent.slice(indentationSize)}}`;
}

const indentation = "    ";
const indentationSize = indentation.length;
